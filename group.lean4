class semigroup (α : Type u) extends HMul α α α where
  mul_assoc : ∀ a b c : α, a * b * c = a * (b * c)

class has_one (α : Type u) where
  one : α

class monoid (α : Type u) extends semigroup α, has_one α where
  one_mul : ∀ a : α, one * a = a
  mul_one : ∀ a : α, a * one = a

class has_inv (α : Type u) extends semigroup α, HDiv α α α where
  inv : α → α
  inv_eq_div : ∀ a b : α, a / b = a * (inv a)

class group (α : Type u) extends monoid α, has_inv α where
  mul_left_inv : ∀ a : α, inv a * a = one

theorem inv_invo (g : group α) : ∀ a : α, g.inv (g.inv a) = a := by
  intro a
  have h := (g.mul_left_inv (g.inv a))
  have h2 : g.inv (g.inv a) * (g.inv a) * a = a := by {
    rw[h]
    apply g.one_mul
  }
  rw [g.mul_assoc] at h2
  rw [g.mul_left_inv a] at h2
  rw [g.mul_one] at h2
  exact h2

theorem inv_one_eq_one (g : group α) : g.inv g.one = g.one := by
  have h : (g.inv g.one) * g.one = g.one := g.mul_left_inv g.one
  have k := g.mul_one (g.inv g.one)
  rw [k] at h
  exact h

theorem mul_right_inv (g : group α) : ∀ a : α, a * (g.inv a) = g.one := by
  intro a
  have h := g.mul_left_inv (group.inv a)
  rw [inv_invo] at h
  exact h

class Set (α : Type u) where
  isMember : α → Prop

instance : Membership α (Set α) where
  mem := fun x s => s.isMember x

class subgroup (G : group α) (S : Set α) where
  mul_mem : ∀ a b : α, a ∈ S → b ∈ S → a * b ∈ S
  one_mem : G.one ∈ S
  inv_mem : ∀ a : α, a ∈ S → G.inv a ∈ S

instance whole_group : Set α where
  isMember := fun _ => True

theorem self_is_subgroup {G : group α} : subgroup G whole_group := by
  have hmul_mem : ∀ a b : α, a ∈ whole_group → b ∈ whole_group → a * b ∈ whole_group := by
    rw [whole_group]
    intros a b _ _
    rw [Membership.mem, instMembershipSet]
    simp
  have hone_mem : G.one ∈ whole_group := by
    rw [Membership.mem, instMembershipSet]
    simp
    rw [Set.isMember, whole_group]
    simp
  have hinv_mem : ∀ a : α, a ∈ whole_group → G.inv a ∈ whole_group := by
    intros a _
    rw [Membership.mem, instMembershipSet]
    simp
    rw [Set.isMember, whole_group]
    simp
  exact {
    mul_mem := hmul_mem
    one_mem := hone_mem
    inv_mem := hinv_mem
  }

instance trivial_subgroup (G : group α) : Set α where
  isMember := fun x => x = G.one

theorem triv_is_subgroup {G : group α} : subgroup G (trivial_subgroup G) := by
  let H := trivial_subgroup G
  have hH : H = trivial_subgroup G := by simp
  rw [← hH]
  have hmul_mem : ∀ a b : α, a ∈ H → b ∈ H → a * b ∈ H := by
    intros a b ha hb
    rw [Membership.mem, instMembershipSet] at ha
    simp at ha
    rw [Set.isMember, trivial_subgroup] at ha
    simp at ha
    rw [Membership.mem, instMembershipSet] at hb
    simp at hb
    rw [Set.isMember, trivial_subgroup] at hb
    simp at hb
    rw [ha, hb]
    rw [G.mul_one]
    simp
    rw [trivial_subgroup, Membership.mem, instMembershipSet]
    simp
  have hone_mem : G.one ∈ H := by
    rw [Membership.mem, instMembershipSet]
    simp
    rw [Set.isMember, trivial_subgroup]
  have hinv_mem : ∀ a : α, a ∈ H → G.inv a ∈ H := by
    intros a ha
    rw [Membership.mem, instMembershipSet] at ha
    simp at ha
    rw [Set.isMember, trivial_subgroup] at ha
    simp at ha
    rw [ha]
    apply inv_one_eq_one
  exact {
    mul_mem := hmul_mem
    one_mem := hone_mem
    inv_mem := hinv_mem
  }
